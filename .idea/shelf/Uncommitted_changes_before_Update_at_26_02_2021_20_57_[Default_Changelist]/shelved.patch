Index: Python/pygame/setup.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nautor : https://github.com/StevePaget\r\n\r\nhttps://github.com/StevePaget/Pygame_Functions\r\n\r\n\r\n\"\"\"\r\nimport pygame, sys, os\r\n\r\nfrom pathlib import Path\r\nDIR = Path(__file__).parent.absolute()\r\nDIR = f'{DIR}'.replace('\\\\','/')\r\nos.chdir(DIR)\r\n\r\n\r\nclass Texte:\r\n    def __init__(self, text, x, y, color, font, taille):\r\n        self.text = text\r\n        self.x = x\r\n        self.y = y\r\n        self.color = color\r\n        self.font = pygame.font.SysFont(font, taille)\r\n\r\n    def write(self, screen):\r\n        screen.blit(self.font.render(self.text, 1, self.color), (self.x, self.y))\r\n\r\n\r\nclass Center_texte:\r\n    def __init__(self, text, x, y, color, font, taille):\r\n        self.text = text\r\n        self.x = x\r\n        self.y = y\r\n        self.color = color\r\n        self.font = pygame.font.SysFont(font, taille)\r\n\r\n    def write(self, screen):\r\n        text = self.font.render(self.text, 1, self.color)\r\n        text_rect = text.get_rect(center=(self.x, self.y))\r\n        return text, text_rect\r\n\r\n\r\nclass Button:\r\n    def __init__(self, text, x, y, color):\r\n        self.text = text\r\n        self.x = x\r\n        self.y = y\r\n        self.color = color\r\n        self.width = 150\r\n        self.height = 100\r\n\r\n    def draw(self, screen):\r\n        \"\"\"\r\n        Repenser cette fonction pour directement donner les coordonnée du centre du boutton...\r\n\r\n\r\n        :param screen:\r\n        :return:\r\n        \"\"\"\r\n\r\n        pygame.draw.rect(screen, self.color, (self.x, self.y, self.width, self.height))\r\n        font = pygame.font.SysFont(\"comicsans\", 40)\r\n        text = font.render(self.text, 1, (255, 255, 255))\r\n        screen.blit(text, (self.x + round(self.width / 2) - round(text.get_width() / 2),\r\n                           self.y + round(self.height / 2) - round(text.get_height() / 2)))\r\n\r\n    def click(self, pos):\r\n        \"\"\"\r\n                Repenser cette fonction pour directement donner les coordonnée du centre du boutton...\r\n\r\n\r\n                :param screen:\r\n                :return:\r\n        \"\"\"\r\n        x1 = pos[0]\r\n        y1 = pos[1]\r\n        if self.x <= x1 <= self.x + self.width and self.y <= y1 <= self.y + self.height:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\nclass Button_center:\r\n    def __init__(self, text, x, y, width, height, color):\r\n        self.text = text\r\n        self.color = color\r\n        ##################################\r\n        if width != None:\r\n            self.width = width\r\n        else:\r\n            self.width = 150\r\n        ##################################\r\n        if width != None:\r\n            self.height = height\r\n        else:\r\n            self.height = 100\r\n        ##################################\r\n\r\n        self.x = x - self.width / 2\r\n        self.y = y - self.height / 2\r\n\r\n    def draw(self, screen):\r\n        \"\"\"\r\n        Repenser cette fonction pour directement donner les coordonnée du centre du boutton...\r\n\r\n\r\n        :param screen:\r\n        :return:\r\n        \"\"\"\r\n        pygame.draw.rect(screen, self.color, (self.x, self.y, self.width, self.height))\r\n        font = pygame.font.SysFont(\"comicsans\", 40)\r\n        text = font.render(self.text, 1, (255, 255, 255))\r\n        screen.blit(text, (self.x + round(self.width / 2) - round(text.get_width() / 2),\r\n                           self.y + round(self.height / 2) - round(text.get_height() / 2)))\r\n\r\n    def click(self, pos):\r\n        \"\"\"\r\n                Repenser cette fonction pour directement donner les coordonnée du centre du boutton...\r\n\r\n\r\n                :param screen:\r\n                :return:\r\n        \"\"\"\r\n        x1 = pos[0]\r\n        y1 = pos[1]\r\n        if self.x <= x1 <= self.x + self.width and self.y <= y1 <= self.y + self.height:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n\r\npygame.mixer.pre_init(44100, -16, 2, 512)\r\npygame.init()\r\npygame.mixer.init()\r\nspriteGroup = pygame.sprite.OrderedUpdates()\r\ntextboxGroup = pygame.sprite.OrderedUpdates()\r\ngameClock = pygame.time.Clock()\r\nmusicPaused = False\r\nhiddenSprites = pygame.sprite.OrderedUpdates()\r\nscreenRefresh = True\r\nbackground = None\r\n\r\nkeydict = {\"space\": pygame.K_SPACE, \"esc\": pygame.K_ESCAPE, \"up\": pygame.K_UP, \"down\": pygame.K_DOWN,\r\n           \"left\": pygame.K_LEFT, \"right\": pygame.K_RIGHT, \"return\": pygame.K_RETURN,\r\n           \"a\": pygame.K_a,\r\n           \"b\": pygame.K_b,\r\n           \"c\": pygame.K_c,\r\n           \"d\": pygame.K_d,\r\n           \"e\": pygame.K_e,\r\n           \"f\": pygame.K_f,\r\n           \"g\": pygame.K_g,\r\n           \"h\": pygame.K_h,\r\n           \"i\": pygame.K_i,\r\n           \"j\": pygame.K_j,\r\n           \"k\": pygame.K_k,\r\n           \"l\": pygame.K_l,\r\n           \"m\": pygame.K_m,\r\n           \"n\": pygame.K_n,\r\n           \"o\": pygame.K_o,\r\n           \"p\": pygame.K_p,\r\n           \"q\": pygame.K_q,\r\n           \"r\": pygame.K_r,\r\n           \"s\": pygame.K_s,\r\n           \"t\": pygame.K_t,\r\n           \"u\": pygame.K_u,\r\n           \"v\": pygame.K_v,\r\n           \"w\": pygame.K_w,\r\n           \"x\": pygame.K_x,\r\n           \"y\": pygame.K_y,\r\n           \"z\": pygame.K_z,\r\n           \"1\": pygame.K_1,\r\n           \"2\": pygame.K_2,\r\n           \"3\": pygame.K_3,\r\n           \"4\": pygame.K_4,\r\n           \"5\": pygame.K_5,\r\n           \"6\": pygame.K_6,\r\n           \"7\": pygame.K_7,\r\n           \"8\": pygame.K_8,\r\n           \"9\": pygame.K_9,\r\n           \"0\": pygame.K_0,\r\n           \"num0\": pygame.K_KP0,\r\n           \"num1\": pygame.K_KP1,\r\n           \"num2\": pygame.K_KP2,\r\n           \"num3\": pygame.K_KP3,\r\n           \"num4\": pygame.K_KP4,\r\n           \"num5\": pygame.K_KP5,\r\n           \"num6\": pygame.K_KP6,\r\n           \"num7\": pygame.K_KP7,\r\n           \"num8\": pygame.K_KP8,\r\n           \"num9\": pygame.K_KP9}\r\nscreen = \"\"\r\n\r\n\r\nclass Background():\r\n    def __init__(self):\r\n        self.colour = pygame.Color(\"black\")\r\n\r\n    def setTiles(self, tiles):\r\n        if type(tiles) is str:\r\n            self.tiles = [[loadImage(tiles)]]\r\n        elif type(tiles[0]) is str:\r\n            self.tiles = [[loadImage(i) for i in tiles]]\r\n        else:\r\n            self.tiles = [[loadImage(i) for i in row] for row in tiles]\r\n        self.stagePosX = 0\r\n        self.stagePosY = 0\r\n        self.tileWidth = self.tiles[0][0].get_width()\r\n        self.tileHeight = self.tiles[0][0].get_height()\r\n        screen.blit(self.tiles[0][0], [0, 0])\r\n        self.surface = screen.copy()\r\n\r\n    def scroll(self, x, y):\r\n        self.stagePosX -= x\r\n        self.stagePosY -= y\r\n        col = (self.stagePosX % (self.tileWidth * len(self.tiles[0]))) // self.tileWidth\r\n        xOff = (0 - self.stagePosX % self.tileWidth)\r\n        row = (self.stagePosY % (self.tileHeight * len(self.tiles))) // self.tileHeight\r\n        yOff = (0 - self.stagePosY % self.tileHeight)\r\n\r\n        col2 = ((self.stagePosX + self.tileWidth) % (self.tileWidth * len(self.tiles[0]))) // self.tileWidth\r\n        row2 = ((self.stagePosY + self.tileHeight) % (self.tileHeight * len(self.tiles))) // self.tileHeight\r\n        screen.blit(self.tiles[row][col], [xOff, yOff])\r\n        screen.blit(self.tiles[row][col2], [xOff + self.tileWidth, yOff])\r\n        screen.blit(self.tiles[row2][col], [xOff, yOff + self.tileHeight])\r\n        screen.blit(self.tiles[row2][col2], [xOff + self.tileWidth, yOff + self.tileHeight])\r\n\r\n        self.surface = screen.copy()\r\n\r\n    def setColour(self, colour):\r\n        self.colour = parseColour(colour)\r\n        screen.fill(self.colour)\r\n        pygame.display.update()\r\n        self.surface = screen.copy()\r\n\r\n\r\nclass newSprite(pygame.sprite.Sprite):\r\n    def __init__(self, filename, frames=1, altDims = None):\r\n        pygame.sprite.Sprite.__init__(self)\r\n        self.images = []\r\n        img = loadImage(filename)\r\n        if altDims:\r\n            img = pygame.transform.scale(img, (altDims[0]*frames, altDims[1]))\r\n        self.originalWidth = img.get_width() // frames\r\n        self.originalHeight = img.get_height()\r\n        frameSurf = pygame.Surface((self.originalWidth, self.originalHeight), pygame.SRCALPHA, 32)\r\n        x = 0\r\n        for frameNo in range(frames):\r\n            frameSurf = pygame.Surface((self.originalWidth, self.originalHeight), pygame.SRCALPHA, 32)\r\n            frameSurf.blit(img, (x, 0))\r\n            self.images.append(frameSurf.copy())\r\n            x -= self.originalWidth\r\n        self.image = pygame.Surface.copy(self.images[0])\r\n\r\n        self.currentImage = 0\r\n        self.rect = self.image.get_rect()\r\n        self.rect.topleft = (0, 0)\r\n        self.mask = pygame.mask.from_surface(self.image)\r\n        self.angle = 0\r\n        self.scale = 1\r\n\r\n    def addImage(self, filename):\r\n        self.images.append(loadImage(filename))\r\n\r\n    def move(self, xpos, ypos, centre=False):\r\n        if centre:\r\n            self.rect.center = [xpos, ypos]\r\n        else:\r\n            self.rect.topleft = [xpos, ypos]\r\n\r\n    def changeImage(self, index):\r\n        self.currentImage = index\r\n        if self.angle == 0 and self.scale == 1:\r\n            self.image = self.images[index]\r\n        else:\r\n            self.image = pygame.transform.rotozoom(self.images[self.currentImage], -self.angle, self.scale)\r\n        oldcenter = self.rect.center\r\n        self.rect = self.image.get_rect()\r\n        originalRect = self.images[self.currentImage].get_rect()\r\n        self.originalWidth = originalRect.width\r\n        self.originalHeight = originalRect.height\r\n        self.rect.center = oldcenter\r\n        self.mask = pygame.mask.from_surface(self.image)\r\n        if screenRefresh:\r\n            updateDisplay()\r\n\r\n\r\nclass newTextBox(pygame.sprite.Sprite):\r\n    def __init__(self, text, xpos, ypos, width, case, maxLength, fontSize):\r\n        pygame.sprite.Sprite.__init__(self)\r\n        self.text = \"\"\r\n        self.width = width\r\n        self.initialText = text\r\n        self.case = case\r\n        self.maxLength = maxLength\r\n        self.boxSize = int(fontSize * 1.7)\r\n        self.image = pygame.Surface((width, self.boxSize))\r\n        self.image.fill((255, 255, 255))\r\n        pygame.draw.rect(self.image, (0, 0, 0), [0, 0, width - 1, self.boxSize - 1], 2)\r\n        self.rect = self.image.get_rect()\r\n        self.fontFace = pygame.font.match_font(\"Arial\")\r\n        self.fontColour = pygame.Color(\"black\")\r\n        self.initialColour = (180, 180, 180)\r\n        self.font = pygame.font.Font(self.fontFace, fontSize)\r\n        self.rect.topleft = [xpos, ypos]\r\n        newSurface = self.font.render(self.initialText, True, self.initialColour)\r\n        self.image.blit(newSurface, [10, 5])\r\n\r\n    def update(self, keyevent):\r\n        key = keyevent.key\r\n        unicode = keyevent.unicode\r\n        if (31 < key < 127 or 255 < key < 266) and (\r\n                self.maxLength == 0 or len(self.text) < self.maxLength):  # only printable characters\r\n            if keyevent.mod in (1, 2) and self.case == 1 and key >= 97 and key <= 122:\r\n                # force lowercase letters\r\n                self.text += chr(key)\r\n            elif keyevent.mod == 0 and self.case == 2 and key >= 97 and key <= 122:\r\n                self.text += chr(key - 32)\r\n            else:\r\n                # use the unicode char\r\n                self.text += unicode\r\n\r\n        elif key == 8:\r\n            # backspace. repeat until clear\r\n            keys = pygame.key.get_pressed()\r\n            nexttime = pygame.time.get_ticks() + 200\r\n            deleting = True\r\n            while deleting:\r\n                keys = pygame.key.get_pressed()\r\n                if keys[pygame.K_BACKSPACE]:\r\n                    thistime = pygame.time.get_ticks()\r\n                    if thistime > nexttime:\r\n                        self.text = self.text[0:len(self.text) - 1]\r\n                        self.image.fill((255, 255, 255))\r\n                        pygame.draw.rect(self.image, (0, 0, 0), [0, 0, self.width - 1, self.boxSize - 1], 2)\r\n                        newSurface = self.font.render(self.text, True, self.fontColour)\r\n                        self.image.blit(newSurface, [10, 5])\r\n                        updateDisplay()\r\n                        nexttime = thistime + 50\r\n                        pygame.event.clear()\r\n                else:\r\n                    deleting = False\r\n\r\n        self.image.fill((255, 255, 255))\r\n        pygame.draw.rect(self.image, (0, 0, 0), [0, 0, self.width - 1, self.boxSize - 1], 2)\r\n        newSurface = self.font.render(self.text, True, self.fontColour)\r\n        self.image.blit(newSurface, [10, 5])\r\n        if screenRefresh:\r\n            updateDisplay()\r\n\r\n    def move(self, xpos, ypos, centre=False):\r\n        if centre:\r\n            self.rect.topleft = [xpos, ypos]\r\n        else:\r\n            self.rect.center = [xpos, ypos]\r\n\r\n    def clear(self):\r\n        self.image.fill((255, 255, 255))\r\n        pygame.draw.rect(self.image, (0, 0, 0), [0, 0, self.width - 1, self.boxSize - 1], 2)\r\n        newSurface = self.font.render(self.initialText, True, self.initialColour)\r\n        self.image.blit(newSurface, [10, 5])\r\n        if screenRefresh:\r\n            updateDisplay()\r\n\r\n\r\nclass newLabel(pygame.sprite.Sprite):\r\n    def __init__(self, text, fontSize, font, fontColour, xpos, ypos, background):\r\n        pygame.sprite.Sprite.__init__(self)\r\n        self.text = text\r\n        self.fontColour = parseColour(fontColour)\r\n        self.fontFace = pygame.font.match_font(font)\r\n        self.fontSize = fontSize\r\n        self.background = background\r\n        self.font = pygame.font.Font(self.fontFace, self.fontSize)\r\n        self.renderText()\r\n        self.rect.topleft = [xpos, ypos]\r\n\r\n    def update(self, newText, fontColour, background):\r\n        self.text = newText\r\n        if fontColour:\r\n            self.fontColour = parseColour(fontColour)\r\n        if background:\r\n            self.background = parseColour(background)\r\n\r\n        oldTopLeft = self.rect.topleft\r\n        self.renderText()\r\n        self.rect.topleft = oldTopLeft\r\n        if screenRefresh:\r\n            updateDisplay()\r\n\r\n    def renderText(self):\r\n        lineSurfaces = []\r\n        textLines = self.text.split(\"<br>\")\r\n        maxWidth = 0\r\n        maxHeight = 0\r\n        for line in textLines:\r\n            lineSurfaces.append(self.font.render(line, True, self.fontColour))\r\n            thisRect = lineSurfaces[-1].get_rect()\r\n            if thisRect.width > maxWidth:\r\n                maxWidth = thisRect.width\r\n            if thisRect.height > maxHeight:\r\n                maxHeight = thisRect.height\r\n        self.image = pygame.Surface((maxWidth, (self.fontSize + 1) * len(textLines) + 5), pygame.SRCALPHA, 32)\r\n        self.image.convert_alpha()\r\n        if self.background != \"clear\":\r\n            self.image.fill(parseColour(self.background))\r\n        linePos = 0\r\n        for lineSurface in lineSurfaces:\r\n            self.image.blit(lineSurface, [0, linePos])\r\n            linePos += self.fontSize + 1\r\n        self.rect = self.image.get_rect()\r\n\r\n\r\ndef loadImage(fileName, useColorKey=False):\r\n    if os.path.isfile(fileName):\r\n        image = pygame.image.load(fileName)\r\n        image = image.convert_alpha()\r\n        # Return the image\r\n        return image\r\n    else:\r\n        raise Exception(f\"Error loading image: {fileName} – Check filename and path?\")\r\n\r\n\r\ndef screenSize(sizex, sizey, xpos=None, ypos=None, fullscreen=False):\r\n    global screen\r\n    global background\r\n    if xpos != None and ypos != None:\r\n        os.environ['SDL_VIDEO_WINDOW_POS'] = f\"{xpos}, {ypos + 50}\"\r\n    else:\r\n        windowInfo = pygame.display.Info()\r\n        monitorWidth = windowInfo.current_w\r\n        monitorHeight = windowInfo.current_h\r\n        os.environ['SDL_VIDEO_WINDOW_POS'] = f\"{(monitorWidth - sizex) // 2}, {(monitorHeight - sizey) // 2}\"\r\n    if fullscreen:\r\n        screen = pygame.display.set_mode([sizex, sizey], pygame.FULLSCREEN)\r\n    else:\r\n        screen = pygame.display.set_mode([sizex, sizey])\r\n    background = Background()\r\n    screen.fill(background.colour)\r\n    pygame.display.set_caption(\"Graphics Window\")\r\n    background.surface = screen.copy()\r\n    pygame.display.update()\r\n    return screen\r\n\r\n\r\n\r\ndef moveSprite(sprite, x, y, centre=False):\r\n    sprite.move(x, y, centre)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef rotateSprite(sprite, angle):\r\n    print(\"rotateSprite has been deprecated. Please use transformSprite\")\r\n    transformSprite(sprite, angle, 1)\r\n\r\n\r\ndef transformSprite(sprite, angle, scale, hflip=False, vflip=False):\r\n    oldmiddle = sprite.rect.center\r\n    if hflip or vflip:\r\n        tempImage = pygame.transform.flip(sprite.images[sprite.currentImage], hflip, vflip)\r\n    else:\r\n        tempImage = sprite.images[sprite.currentImage]\r\n    if angle != 0 or scale != 1:\r\n        sprite.angle = angle\r\n        sprite.scale = scale\r\n        tempImage = pygame.transform.rotozoom(tempImage, -angle, scale)\r\n    sprite.image = tempImage\r\n    sprite.rect = sprite.image.get_rect()\r\n    sprite.rect.center = oldmiddle\r\n    sprite.mask = pygame.mask.from_surface(sprite.image)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef killSprite(sprite):\r\n    sprite.kill()\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef setBackgroundColour(colour):\r\n    background.setColour(colour)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef setBackgroundImage(img):\r\n    global background\r\n    background.setTiles(img)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef hideSprite(sprite):\r\n    hiddenSprites.add(sprite)\r\n    spriteGroup.remove(sprite)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef hideAll():\r\n    hiddenSprites.add(spriteGroup.sprites())\r\n    spriteGroup.empty()\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef unhideAll():\r\n    spriteGroup.add(hiddenSprites.sprites())\r\n    hiddenSprites.empty()\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef showSprite(sprite):\r\n    spriteGroup.add(sprite)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef makeSprite(filename, frames=1, altDims = None):\r\n    thisSprite = newSprite(filename, frames, altDims)\r\n    return thisSprite\r\n\r\n\r\ndef addSpriteImage(sprite, image):\r\n    sprite.addImage(image)\r\n\r\n\r\ndef changeSpriteImage(sprite, index):\r\n    sprite.changeImage(index)\r\n\r\n\r\ndef nextSpriteImage(sprite):\r\n    sprite.currentImage += 1\r\n    if sprite.currentImage > len(sprite.images) - 1:\r\n        sprite.currentImage = 0\r\n    sprite.changeImage(sprite.currentImage)\r\n\r\n\r\ndef prevSpriteImage(sprite):\r\n    sprite.currentImage -= 1\r\n    if sprite.currentImage < 0:\r\n        sprite.currentImage = len(sprite.images) - 1\r\n    sprite.changeImage(sprite.currentImage)\r\n\r\n\r\ndef makeImage(filename):\r\n    return loadImage(filename)\r\n\r\n\r\ndef touching(sprite1, sprite2):\r\n    collided = pygame.sprite.collide_mask(sprite1, sprite2)\r\n    return collided\r\n\r\n\r\ndef allTouching(spritename):\r\n    if spriteGroup.has(spritename):\r\n        collisions = pygame.sprite.spritecollide(spritename, spriteGroup, False, collided=pygame.sprite.collide_mask)\r\n        collisions.remove(spritename)\r\n        return collisions\r\n    else:\r\n        return []\r\n\r\n\r\ndef pause(milliseconds, allowEsc=True):\r\n    keys = pygame.key.get_pressed()\r\n    current_time = pygame.time.get_ticks()\r\n    waittime = current_time + milliseconds\r\n    updateDisplay()\r\n    while not (current_time > waittime or (keys[pygame.K_ESCAPE] and allowEsc)):\r\n        pygame.event.clear()\r\n        keys = pygame.key.get_pressed()\r\n        if (keys[pygame.K_ESCAPE] and allowEsc):\r\n            pygame.quit()\r\n            sys.exit()\r\n        current_time = pygame.time.get_ticks()\r\n\r\n\r\ndef drawRect(xpos, ypos, width, height, colour, linewidth=0):\r\n    global bgSurface\r\n    colour = parseColour(colour)\r\n    thisrect = pygame.draw.rect(screen, colour, [xpos, ypos, width, height], linewidth)\r\n    if screenRefresh:\r\n        pygame.display.update(thisrect)\r\n\r\n\r\ndef drawLine(x1, y1, x2, y2, colour, linewidth=1):\r\n    global bgSurface\r\n    colour = parseColour(colour)\r\n    thisrect = pygame.draw.line(screen, colour, (x1, y1), (x2, y2), linewidth)\r\n    if screenRefresh:\r\n        pygame.display.update(thisrect)\r\n\r\n\r\ndef drawPolygon(pointlist, colour, linewidth=0):\r\n    global bgSurface\r\n    colour = parseColour(colour)\r\n    thisrect = pygame.draw.polygon(screen, colour, pointlist, linewidth)\r\n    if screenRefresh:\r\n        pygame.display.update(thisrect)\r\n\r\n\r\ndef drawEllipse(centreX, centreY, width, height, colour, linewidth=0):\r\n    global bgSurface\r\n    colour = parseColour(colour)\r\n    thisrect = pygame.Rect(centreX - width / 2, centreY - height / 2, width, height)\r\n    pygame.draw.ellipse(screen, colour, thisrect, linewidth)\r\n    if screenRefresh:\r\n        pygame.display.update(thisrect)\r\n\r\n\r\ndef drawTriangle(x1, y1, x2, y2, x3, y3, colour, linewidth=0):\r\n    global bgSurface\r\n    colour = parseColour(colour)\r\n    thisrect = pygame.draw.polygon(screen, colour, [(x1, y1), (x2, y2), (x3, y3)], linewidth)\r\n    if screenRefresh:\r\n        pygame.display.update(thisrect)\r\n\r\n\r\ndef clearShapes():\r\n    global background\r\n    screen.blit(background.surface, [0, 0])\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef updateShapes():\r\n    pygame.display.update()\r\n\r\n\r\ndef end():\r\n    pygame.quit()\r\n\r\n\r\ndef makeSound(filename):\r\n    pygame.mixer.init()\r\n    thissound = pygame.mixer.Sound(filename)\r\n\r\n    return thissound\r\n\r\n\r\ndef playSound(sound, loops=0):\r\n    sound.play(loops)\r\n\r\n\r\ndef stopSound(sound):\r\n    sound.stop()\r\n\r\n\r\ndef playSoundAndWait(sound):\r\n    sound.play()\r\n    while pygame.mixer.get_busy():\r\n        # pause\r\n        pause(10)\r\n\r\n\r\ndef makeMusic(filename):\r\n    pygame.mixer.music.load(filename)\r\n\r\n\r\ndef playMusic(loops=0):\r\n    global musicPaused\r\n    if musicPaused:\r\n        pygame.mixer.music.unpause()\r\n    else:\r\n        pygame.mixer.music.play(loops)\r\n    musicPaused = False\r\n\r\n\r\ndef stopMusic():\r\n    pygame.mixer.music.stop()\r\n\r\n\r\ndef pauseMusic():\r\n    global musicPaused\r\n    pygame.mixer.music.pause()\r\n    musicPaused = True\r\n\r\n\r\ndef rewindMusic():\r\n    pygame.mixer.music.rewind()\r\n\r\n\r\ndef endWait():\r\n    updateDisplay()\r\n    print(\"Press ESC to quit\")\r\n    waiting = True\r\n    while waiting:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == keydict[\"esc\"]):\r\n                waiting = False\r\n    pygame.quit()\r\n    exit()\r\n\r\n\r\n\r\ndef keyPressed(keyCheck=\"\"):\r\n    global keydict\r\n    keys = pygame.key.get_pressed()\r\n    if sum(keys) > 0:\r\n        if keyCheck == \"\" or keys[keydict[keyCheck.lower()]]:\r\n            return True\r\n    return False\r\n\r\n\r\ndef makeLabel(text, fontSize, xpos, ypos, fontColour='black', font='Arial', background=\"clear\"):\r\n    # make a text sprite\r\n    thisText = newLabel(text, fontSize, font, fontColour, xpos, ypos, background)\r\n    return thisText\r\n\r\n\r\ndef moveLabel(sprite, x, y):\r\n    sprite.rect.topleft = [x, y]\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef changeLabel(textObject, newText, fontColour=None, background=None):\r\n    textObject.update(newText, fontColour, background)\r\n    # updateDisplay()\r\n\r\n\r\ndef waitPress():\r\n    pygame.event.clear()\r\n    keypressed = False\r\n    thisevent = pygame.event.wait()\r\n    while thisevent.type != pygame.KEYDOWN:\r\n        thisevent = pygame.event.wait()\r\n    return thisevent.key\r\n\r\n\r\ndef makeTextBox(xpos, ypos, width, case=0, startingText=\"Please type here\", maxLength=0, fontSize=22):\r\n    thisTextBox = newTextBox(startingText, xpos, ypos, width, case, maxLength, fontSize)\r\n    textboxGroup.add(thisTextBox)\r\n    return thisTextBox\r\n\r\n\r\ndef textBoxInput(textbox, functionToCall=None, args=[]):\r\n    # starts grabbing key inputs, putting into textbox until enter pressed\r\n    global keydict\r\n    textbox.text = \"\"\r\n    returnVal = None\r\n    while True:\r\n        updateDisplay()\r\n        if functionToCall:\r\n            returnVal = functionToCall(*args)\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.KEYDOWN:\r\n                if event.key == pygame.K_RETURN:\r\n                    textbox.clear()\r\n                    if returnVal:\r\n                        return textbox.text, returnVal\r\n                    else:\r\n                        return textbox.text\r\n                elif event.key == pygame.K_ESCAPE:\r\n                    pygame.quit()\r\n                    sys.exit()\r\n                else:\r\n                    textbox.update(event)\r\n            elif event.type == pygame.QUIT:\r\n                pygame.quit()\r\n                sys.exit()\r\n\r\n\r\ndef clock():\r\n    current_time = pygame.time.get_ticks()\r\n    return current_time\r\n\r\n\r\ndef tick(fps):\r\n    for event in pygame.event.get():\r\n        if (event.type == pygame.KEYDOWN and event.key == keydict[\"esc\"]) or event.type == pygame.QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n    gameClock.tick(fps)\r\n    return gameClock.get_fps()\r\n\r\n\r\ndef showLabel(labelName):\r\n    textboxGroup.add(labelName)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef hideLabel(labelName):\r\n    textboxGroup.remove(labelName)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef showTextBox(textBoxName):\r\n    textboxGroup.add(textBoxName)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef hideTextBox(textBoxName):\r\n    textboxGroup.remove(textBoxName)\r\n    if screenRefresh:\r\n        updateDisplay()\r\n\r\n\r\ndef updateDisplay():\r\n    global background\r\n    spriteRects = spriteGroup.draw(screen)\r\n    textboxRects = textboxGroup.draw(screen)\r\n    pygame.display.update()\r\n    keys = pygame.key.get_pressed()\r\n    if (keys[pygame.K_ESCAPE]):\r\n        pygame.quit()\r\n        sys.exit()\r\n    spriteGroup.clear(screen, background.surface)\r\n    textboxGroup.clear(screen, background.surface)\r\n\r\n\r\ndef mousePressed():\r\n    #pygame.event.clear()\r\n    mouseState = pygame.mouse.get_pressed()\r\n    if mouseState[0]:\r\n        return True\r\n    else:\r\n        return False\r\n\r\n\r\ndef spriteClicked(sprite):\r\n    mouseState = pygame.mouse.get_pressed()\r\n    if not mouseState[0]:\r\n        return False  # not pressed\r\n    pos = pygame.mouse.get_pos()\r\n    if sprite.rect.collidepoint(pos):\r\n        return True\r\n    else:\r\n        return False\r\n\r\n\r\ndef parseColour(colour):\r\n    if type(colour) == str:\r\n        # check to see if valid colour\r\n        return pygame.Color(colour)\r\n    else:\r\n        colourRGB = pygame.Color(\"white\")\r\n        colourRGB.r = colour[0]\r\n        colourRGB.g = colour[1]\r\n        colourRGB.b = colour[2]\r\n        return colourRGB\r\n\r\n\r\ndef mouseX():\r\n    x = pygame.mouse.get_pos()\r\n    return x[0]\r\n\r\n\r\ndef mouseY():\r\n    y = pygame.mouse.get_pos()\r\n    return y[1]\r\n\r\n\r\ndef scrollBackground(x, y):\r\n    global background\r\n    background.scroll(x, y)\r\n\r\n\r\ndef setAutoUpdate(val):\r\n    global screenRefresh\r\n    screenRefresh = val\r\n\r\ndef setIcon(iconfile):\r\n    gameicon = pygame.image.load(iconfile)\r\n    pygame.display.set_icon(gameicon)\r\n\r\ndef setWindowTitle(string):\r\n    pygame.display.set_caption(string)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(\"pygame_functions is not designed to be run directly.\\n\" \\\r\n        \"See the wiki at https://github.com/StevePaget/Pygame_Functions/wiki/Getting-Started for more information.\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Python/pygame/setup.py b/Python/pygame/setup.py
--- a/Python/pygame/setup.py	(revision a84840b0dfcdf7140a9285e7bf5a19e317e06829)
+++ b/Python/pygame/setup.py	(date 1614369430000)
@@ -14,7 +14,16 @@
 
 
 class Texte:
-    def __init__(self, text, x, y, color, font, taille):
+    """Pour écrire du texte à l'écran:
+    paramètre:
+        @text: texte à écrire
+        @x : abscisse
+        @y : ordonnée
+        @color : couleur en rgb
+        @font: Police d'écriture A TELECHARGER avant d'utiliser
+        @font_size: taille de la police d'écriture
+    """
+    def __init__(self, text, x, y, color, font, font_size):
         self.text = text
         self.x = x
         self.y = y
@@ -22,10 +31,24 @@
         self.font = pygame.font.SysFont(font, taille)
 
     def write(self, screen):
+        """Injecte le texte à l'écran
+
+        Args:
+            screen (pygae.display): La surface où écrire
+        """
         screen.blit(self.font.render(self.text, 1, self.color), (self.x, self.y))
 
 
 class Center_texte:
+    """Pour écrire du texte à l'écran (CENTRE (x,y) AU MILIEU DU TEXTE):
+    paramètre:
+        @text: texte à écrire
+        @x : abscisse
+        @y : ordonnée
+        @color : couleur en rgb
+        @font: Police d'écriture A TELECHARGER avant d'utiliser
+        @font_size: taille de la police d'écriture
+    """
     def __init__(self, text, x, y, color, font, taille):
         self.text = text
         self.x = x
@@ -40,7 +63,17 @@
 
 
 class Button:
-    def __init__(self, text, x, y, color):
+    def __init__(self, text, x, y, color, width, height):
+        """Dessine un boutton
+
+        Args:
+            text (str): Le texte affiché sur le bouton
+            x (int): abscisse
+            y (int): ordonnée
+            color (tuple): couleur en rgb
+            width (int): largeur
+            height (int): hauteur
+        """
         self.text = text
         self.x = x
         self.y = y
@@ -50,13 +83,6 @@
 
     def draw(self, screen):
         """
-        Repenser cette fonction pour directement donner les coordonnée du centre du boutton...
-
-
-        :param screen:
-        :return:
-        """
-
         pygame.draw.rect(screen, self.color, (self.x, self.y, self.width, self.height))
         font = pygame.font.SysFont("comicsans", 40)
         text = font.render(self.text, 1, (255, 255, 255))
@@ -64,13 +90,7 @@
                            self.y + round(self.height / 2) - round(text.get_height() / 2)))
 
     def click(self, pos):
-        """
-                Repenser cette fonction pour directement donner les coordonnée du centre du boutton...
 
-
-                :param screen:
-                :return:
-        """
         x1 = pos[0]
         y1 = pos[1]
         if self.x <= x1 <= self.x + self.width and self.y <= y1 <= self.y + self.height:
@@ -193,7 +213,7 @@
 
 class Background():
     def __init__(self):
-        self.colour = pygame.Color("black")
+        self.colour = pygame.Color("gray")
 
     def setTiles(self, tiles):
         if type(tiles) is str:
Index: server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket\r\nfrom _thread import *\r\nimport pickle\r\nfrom game import Game\r\n\r\n# local = 192.168.1.27\r\n# server = 193.168.147.3\r\nserver = \"193.168.147.3\"\r\nport = 5555\r\n\r\n\r\n\r\n# bind le port\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n\r\ntry:\r\n    s.bind((server, port))\r\nexcept socket.error as e:\r\n    str(e)\r\n\r\ns.listen(2)\r\nprint(\"Pas de connexion, Server ready !\")\r\n\r\nconnected = set()\r\ngames = {}\r\nidCount = 0\r\n\r\n\r\ndef threaded_client(conn, idJoueur, ishost):\r\n    global nbjconnecte\r\n    global host\r\n    running_lobby = True\r\n\r\n    while True:\r\n\r\n        while running_lobby:\r\n            \"\"\"\r\n            On envoie les infos sur la partie.\r\n            \"\"\"\r\n\r\n\r\n            \"\"\"\r\n            On recupere les informations de la partie.\r\n\r\n            \"\"\"\r\n            try:\r\n                print(len(IdJoueurUtilise))\r\n                conn.send(str.encode(str(idJoueur) + \"|\" + str(ishost) + \"|\" + str(len(IdJoueurUtilise))))\r\n                data = conn.recv(4096).decode()\r\n                if not data:\r\n                    break\r\n                else:\r\n                    print(\"data = \" + str(data))\r\n            except:\r\n                print(\"Connexion perdu.\")\r\n                running_lobby = False\r\n\r\n\r\n        \"\"\"\r\n        cas d'une déco.\r\n        \"\"\"\r\n\r\n        if running_lobby == False:\r\n            print(\"Lost connection\")\r\n            IdJoueurUtilise.remove(idJoueur)\r\n            nbjconnecte -= 1\r\n            if hostPlayerId == idJoueur:\r\n                if nbjconnecte>0:\r\n                    hostPlayerId = IdJoueurUtilise[0]\r\n                else:\r\n                    host = False\r\n\r\n            try:\r\n                del games[gameId]\r\n                print(\"Closing Game\", gameId)\r\n            except:\r\n                pass\r\n\r\n            conn.close()\r\n            break\r\n\r\n\r\n\r\nIdJoueurUtilise = []\r\nglobal nbjconnecte\r\nglobal host\r\nglobal hostPlayerId\r\nnbjconnecte = 0\r\nnbjmax = 7\r\nhost = False\r\nwhile True:\r\n    conn, addr = s.accept()\r\n    print(\"Connected to:\", addr)\r\n\r\n    if nbjconnecte == nbjmax:\r\n        conn.send(str.encode(str(\"Error|PlayerLimit\")))\r\n    else:\r\n\r\n        i = 0\r\n        IdJoueur = 0\r\n        while IdJoueur == 0 and i < nbjmax:\r\n            i += 1\r\n            if IdJoueurUtilise.count(i) == 0:\r\n                IdJoueur = i\r\n\r\n        IdJoueurUtilise.append(IdJoueur)\r\n        print(\"Id Joueur = \" + str(IdJoueur))\r\n\r\n        nbjconnecte += 1\r\n\r\n        if host == False:\r\n            ishost = 1\r\n            host = True\r\n            hostPlayerId = IdJoueur\r\n        else:\r\n            ishost = 0\r\n\r\n        start_new_thread(threaded_client, (conn, IdJoueur, ishost))\r\n    print(IdJoueurUtilise)\r\n\"\"\"\r\n    idCount += 1\r\n    p = 0\r\n    gameId = (idCount - 1)//2\r\n    if idCount % 2 == 1:\r\n        games[gameId] = Game(gameId)\r\n        print(\"Creating a new game...\")\r\n    else:\r\n        games[gameId].ready = True\r\n        p = 1\r\n\r\n\r\n    start_new_thread(threaded_client, (conn, p, gameId))\r\n\r\n\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server.py b/server.py
--- a/server.py	(revision a84840b0dfcdf7140a9285e7bf5a19e317e06829)
+++ b/server.py	(date 1614369430000)
@@ -9,6 +9,48 @@
 port = 5555
 
 
+class Server:
+    def __init__(self, id, port):
+        self.id = id
+        self.port = port
+        self.hote = self.get_hote(self)
+        """
+        int: 3 état:
+        0 éteint
+        1 allumé - lobby
+        2 allumé - partie en cours
+        """
+        self.etat = 0
+
+    def start(self):
+        self.etat = 1
+        try:
+            s.bind((server, port))
+        except socket.error as e:
+            str(e)
+            self.etat = 0
+        return self.etat
+
+    def get_joueurs(self):
+        """
+        retourne une liste avec les joueurs
+
+        :return:
+        retourne la liste des joueurs.
+        """
+        return ["Bob"]
+
+    def get_host(self):
+        """
+        Définit qui est l'hote de la partie.
+
+        :return:
+        retourne le premier joueurs de la liste.
+        """
+        joueurs = self.get_joueurs()
+        self.hote = joueurs[0]
+        return joueurs[0]
+
 
 # bind le port
 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
Index: client.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nfrom Python.network.network import Network\r\nfrom Python.conf import settings\r\nfrom Python.pygame import setup as f\r\nfrom Python.network import network as n\r\n\r\n\"\"\"\r\nAffichage :\r\n    Menu de chargement \r\n    \r\n    \r\nProcess:\r\n    Verifier les fichiers du jeu\r\n    Download fichié Maj / reinstall si check sum =/= d'habitude? \r\n    Chargement des paramètres de jeu.\r\n    \r\n\"\"\"\r\n\r\n\r\ndef loading():\r\n    # Check intégrité jeu (ac)\r\n    # Download parties du jeu online\r\n    #\r\n    # Si premiere connexion, enregistré pseudo.\r\n    #\r\n    #\r\n    reglages = settings.Settings()\r\n    global window_width\r\n    window_width = reglages.get_window_width()\r\n    global window_height\r\n    window_height = reglages.get_window_height()\r\n    global pseudo\r\n    pseudo = reglages.get_pseudo()\r\n    # Init Pygame\r\n    pygame.font.init()\r\n\r\n\r\ndef reglage():\r\n    screen.fill(0)\r\n    running = True\r\n    while running:\r\n        Fermer = f.Center_texte(\"Y en a pas !\", window_width / 2, window_width * 0.30,\r\n                                (0, 0, 255),\r\n                                \"ComicSansMS\", 40)\r\n        text, text_rect = Fermer.write(screen)\r\n        btn = f.Button_center(\"Menu (retour)\", window_width / 2, window_height *0.6, 200, 70, (255, 155, 0))\r\n        btn.draw(screen)\r\n        screen.blit(text, text_rect)\r\n        pygame.display.flip()\r\n        for event in pygame.event.get():\r\n            \"\"\"Ferme le prgm en cas de fermeture de la fenetre.\"\"\"\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                pos = pygame.mouse.get_pos()\r\n                if btn.click(pos):\r\n                    running = False\r\n\r\n\r\n\"\"\"\r\nAffichage:\r\n    au milieu bouton de jeu \r\n        pseudo\r\n        \r\n        Solo\r\n        \r\n        Multi\r\n            \r\n            credit défilant.\r\n\r\nprocess:\r\n    wait\r\n\"\"\"\r\n\r\n\r\ndef main_menu():\r\n    screen.fill(0)\r\n    pygame.display.set_caption(\"Menu\")\r\n    draw = 0\r\n    running = True\r\n    while running:\r\n        for event in pygame.event.get():\r\n            \"\"\"Ferme le prgm en cas de fermeture de la fenetre.\"\"\"\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n        Message_Bienvenue = f.Center_texte(\"Citadelle\".upper(), window_width / 2, window_height * 0.10, (0, 255, 0),\r\n                                           \"ComicSansMS\", 50)\r\n        text, text_rect = Message_Bienvenue.write(screen)\r\n        \"\"\"\r\n        if pseudo == \"\":\r\n            message = \"Entre ton pseudo\"\r\n            pseudo = f.TextBoxInput(Pseudo_InputBox)\r\n        else:\r\n            message = pseudo\r\n        \"\"\"\r\n        Pseudo_InputBox = f.makeTextBox(window_width / 2, window_height * 0.70, 300, 0, \"message\")\r\n        #f.showTextBox(Pseudo_InputBox)\r\n        btns = [f.Button_center(\"Solo\", window_width * 0.2, window_height / 2, 150, 100, (0, 0, 255)),\r\n                f.Button_center(\"Multi\", window_width * 0.8, window_height / 2, 150, 100, (0, 0, 255)),\r\n                f.Button_center(\"reglage\", window_width * 0.9, window_height * 0.9, 150, 100, (0, 0, 0)),\r\n                f.Button_center(\"FERMER\", window_width * 0.9, window_height * 0.1, 150, 100, (0, 0, 0))]\r\n        if draw != True:\r\n\r\n            screen.blit(text, text_rect)\r\n            for btn in btns:\r\n                btn.draw(screen)\r\n\r\n            draw = True\r\n\r\n        pygame.display.flip()\r\n        for event in pygame.event.get():\r\n            \"\"\"\r\n            DEBUGG\r\n            Connaitre la position c'est un plus..\r\n            \"\"\"\r\n            if event.type == pygame.MOUSEMOTION:\r\n                # print(pygame.mouse.get_pos())\r\n                pass\r\n            \"\"\"Ferme le prgm en cas de fermeture de la fenetre.\"\"\"\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                pos = pygame.mouse.get_pos()\r\n                for btn in btns:\r\n                    if btn.click(pos):\r\n                        running = False\r\n                        clique = btn\r\n\r\n    if clique.text == \"Solo\":\r\n        Solo()\r\n    elif clique.text == \"Multi\":\r\n        Multijoueurs()\r\n    elif clique.text == \"reglage\":\r\n        reglage()\r\n    elif clique.text == \"FERMER\":\r\n        screen.fill(0)\r\n        Fermer = f.Center_texte(\"Merci d'avoir joué !\", window_width / 2, window_width * 0.30,\r\n                                (0, 255, 0),\r\n                                \"ComicSansMS\", 50)\r\n        text, text_rect = Fermer.write(screen)\r\n        screen.blit(text, text_rect)\r\n        pygame.display.flip()\r\n        pygame.time.delay(1500)\r\n        pygame.display.quit()\r\n        quit()\r\n    pass\r\n\r\n\r\n\"\"\"\r\nGestion Mathieu\r\n\"\"\"\r\n\r\n\r\ndef Solo():\r\n    screen.fill(0)\r\n    Fermer = f.Center_texte(\"Bientôt un Solo !\", window_width / 2, window_width * 0.30,\r\n                            (0, 255, 0),\r\n                            \"ComicSansMS\", 50)\r\n    text, text_rect = Fermer.write(screen)\r\n    screen.blit(text, text_rect)\r\n    pygame.display.flip()\r\n    pygame.time.delay(1500)\r\n\r\n\r\n\"\"\"\r\nConception        Mathieu\r\n\r\nGestion Network   Maxime \r\n\r\n\"\"\"\r\n\r\n\r\ndef Multijoueurs():\r\n    print(\"   _   _              _   _       \")\r\n    print(\"  / \\ / \\     _   _  | | | |_  (_)\")\r\n    print(\" /       \\   | | | | | | | __| | |\")\r\n    print(\"/ / \\ / \\ \\  | |_| | | | | |_ || |\")\r\n    print(\"\\ /     \\ /   \\__,_| |_|  \\__| |_|\")\r\n\r\n    pygame.display.set_caption(\"Citadelle | Multijoueurs\")\r\n    screen.fill(1)\r\n    pygame.display.flip()\r\n    running = True\r\n    Network = n.Network()\r\n    answer = Network.getP()\r\n    print(\"result connexion : \"+answer)\r\n    while running:\r\n        pygame.time.delay(1000)\r\n        answer = Network.Get()\r\n        print(f\"srv :{answer}\")\r\n\r\n\r\n\r\n\r\n        for event in pygame.event.get():\r\n            \"\"\"Ferme le prgm en cas de fermeture de la fenetre.\"\"\"\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n        \"\"\"\r\n        Intérogations serveur : quels sont les serveurs disponible :\r\n        \"\"\"\r\n        \"\"\"\r\n        if PlayerId == \"1\":\r\n            host = True\r\n            f.Center_texte(\"Vous êtes l'hote, c'est vous qui règler les paramètres de la partie !\", window_width / 2, window_width * 0.10,\r\n                           (255, 255, 255),\r\n                           \"ComicSansMS\", 20)\r\n        if changement:\r\n            pygame.display.flip()\r\n        \"\"\"\r\n\r\n\r\n\"\"\"\r\n __  _                _   \r\n/ _\\| |_  __ _  _ __ | |_ \r\n\\ \\ | __|/ _` || '__|| __|\r\n_\\ \\| |_| (_| || |   | |_ \r\n\\__/ \\__|\\__,_||_|    \\__|\r\n\"\"\"\r\nloading()\r\n\r\nscreen = pygame.display.set_mode((window_width, window_height))\r\nwhile True:\r\n    main_menu()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client.py b/client.py
--- a/client.py	(revision a84840b0dfcdf7140a9285e7bf5a19e317e06829)
+++ b/client.py	(date 1614369430000)
@@ -183,11 +183,14 @@
     running = True
     Network = n.Network()
     answer = Network.getP()
-    print("result connexion : "+answer)
+    print(f"result connexion : {answer}")
+
     while running:
         pygame.time.delay(1000)
         answer = Network.Get()
         print(f"srv :{answer}")
+        answer = Network.getP()
+        print("srv :" + answer)
 
 
 
